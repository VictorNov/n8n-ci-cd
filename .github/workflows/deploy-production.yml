name: 3. Deploy to Production (Automated on merge)

permissions:
  contents: write
  issues: write
  actions: write

on:
  push:
    branches: [ prod ]

env:
  NODE_VERSION: '22'

jobs:
  deploy-to-production:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Inject API key
        run: |
          jq --arg key "${{ secrets.N8N_API_KEY }}" '.n8n.apiKey = $key' config/n8n-config.json > tmp.json && mv tmp.json config/n8n-config.json

      - name: Extract deployment metadata
        id: metadata
        run: |
          echo "üîç Extracting deployment metadata"
          
          # Get the full commit message
          merge_message=$(git log -1 --pretty=%B)
          
          # Method 1: Extract from YAML metadata block in PR body
          if echo "$merge_message" | grep -q "Release Metadata"; then
            echo "üìã Found Release Metadata in commit message"
          
            # Extract the YAML block between ```yaml and ```
            metadata_yaml=$(echo "$merge_message" | sed -n '/```yaml/,/```/p' | sed '1d;$d')
          
            if [[ -n "$metadata_yaml" ]]; then
              # Parse YAML fields
              workflow_name=$(echo "$metadata_yaml" | grep "^workflow_name:" | cut -d: -f2- | xargs)
              workflow_prefix=$(echo "$metadata_yaml" | grep "^workflow_prefix:" | cut -d: -f2- | xargs)
              workflow_filename=$(echo "$metadata_yaml" | grep "^workflow_filename:" | cut -d: -f2- | xargs)
              workflow_file=$(echo "$metadata_yaml" | grep "^workflow_file:" | cut -d: -f2- | xargs)
              version=$(echo "$metadata_yaml" | grep "^version:" | cut -d: -f2- | xargs)
              tag_name=$(echo "$metadata_yaml" | grep "^tag_name:" | cut -d: -f2- | xargs)
          
              echo "‚úÖ Extracted metadata from PR body:"
              echo "  Workflow: $workflow_name"
              echo "  Version: $version"
              echo "  Tag: $tag_name"
              metadata_source="pr_metadata"
            else
              echo "‚ö†Ô∏è YAML block not found, trying PR title"
              metadata_source=""
            fi
          fi
          
          # Method 2: Extract from PR title if YAML extraction failed
          if [[ -z "$metadata_source" ]] && [[ "$merge_message" =~ Release[[:space:]]([0-9]+\.[0-9]+\.[0-9]+):[[:space:]](.+) ]]; then
            version="${BASH_REMATCH[1]}"
            workflow_name="${BASH_REMATCH[2]}"
          
            # Regenerate consistent naming formats
            workflow_prefix=$(echo "$workflow_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/^-*//;s/-*$//' | sed 's/--*/-/g')
            workflow_filename=$(echo "$workflow_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/_/g' | sed 's/^_*//;s/_*$//')
            workflow_file="${workflow_filename}.json"
            tag_name="${workflow_prefix}-${version}"
          
            echo "‚úÖ Extracted from PR title: $workflow_name v$version"
            metadata_source="pr_title"
          fi
          
          # Method 3: Fallback to detecting from changed files
          if [[ -z "$metadata_source" ]]; then
            echo "‚ö†Ô∏è No release metadata found, detecting from changed files"
          
            changed_files=$(git diff --name-only HEAD~1 HEAD -- workflows/*.json 2>/dev/null || echo "")
          
            if [[ -z "$changed_files" ]]; then
              echo "‚ö†Ô∏è No workflow changes detected, using first workflow as fallback"
              changed_files=$(ls workflows/*.json 2>/dev/null | head -n1)
            fi
          
            workflow_name=""
            for file in $changed_files; do
              if [[ "$file" =~ ^workflows/(.+)\.json$ ]]; then
                workflow_filename="${BASH_REMATCH[1]}"
                workflow_file="${workflow_filename}.json"
                # Convert filename to readable name
                workflow_name=$(echo "$workflow_filename" | sed 's/_/ /g' | sed 's/\b\w/\U&/g')
                workflow_prefix=$(echo "$workflow_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/^-*//;s/-*$//' | sed 's/--*/-/g')
                break  # Use first workflow found
              fi
            done
          
            if [[ -z "$workflow_name" ]]; then
              echo "‚ùå No workflow found to deploy"
              exit 1
            fi
          
            version="unknown"
            tag_name=""
            metadata_source="file_detection"
          fi
          
          # Output all metadata
          echo "workflow_name=$workflow_name" >> $GITHUB_OUTPUT
          echo "workflow_prefix=$workflow_prefix" >> $GITHUB_OUTPUT
          echo "workflow_filename=$workflow_filename" >> $GITHUB_OUTPUT
          echo "workflow_file=$workflow_file" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "tag_name=$tag_name" >> $GITHUB_OUTPUT
          echo "metadata_source=$metadata_source" >> $GITHUB_OUTPUT
          
          # Log extracted metadata
          echo "üìã Deployment Metadata:"
          echo "  Workflow: $workflow_name"
          echo "  Version: $version"
          echo "  File: workflows/$workflow_file"
          echo "  Tag: $tag_name"
          echo "  Source: $metadata_source"

      - name: Validate workflow file
        run: |
          filepath="workflows/${{ steps.metadata.outputs.workflow_file }}"
          
          echo "üîç Validating workflow file: $filepath"
          
          if [[ ! -f "$filepath" ]]; then
            echo "‚ùå Workflow file not found: $filepath"
            echo "Available files:"
            ls -la workflows/
            exit 1
          fi
          
          if ! jq empty "$filepath" 2>/dev/null; then
            echo "‚ùå Invalid JSON format in: $filepath"
            exit 1
          fi
          
          echo "‚úÖ Workflow file validated successfully"

      - name: Run deployment
        run: |
          echo "üöÄ Deploying to production"
          echo "  Workflow: ${{ steps.metadata.outputs.workflow_name }}"
          echo "  Version: ${{ steps.metadata.outputs.version }}"
          
          node scripts/deployment-manager.js full-deploy \
            "${{ steps.metadata.outputs.workflow_name }}" \
            "false" \
            "${{ github.actor }}" \
            "${{ github.sha }}" \
            "${{ steps.metadata.outputs.version }}"

      - name: Update release with deployment status
        if: success() && steps.metadata.outputs.tag_name != ''
        run: |
          echo "üè∑Ô∏è Updating release with deployment status"
          
          tag_name="${{ steps.metadata.outputs.tag_name }}"
          current_time=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          # Note: You might want to use gh CLI to actually update the release
          echo "Would update release $tag_name with deployment status:"
          echo "  Deployed at: $current_time"
          echo "  Deployed by: ${{ github.actor }}"
          echo "  Commit: ${{ github.sha }}"
          
          # Uncomment to actually update the release:
          # gh release edit "$tag_name" --notes-file <(
          #   gh release view "$tag_name" --json body -q .body
          #   echo ""
          #   echo "## üöÄ Deployment Status"
          #   echo "- **Deployed to Production**: $current_time"
          #   echo "- **Commit**: ${{ github.sha }}"
          #   echo "- **Deployed by**: ${{ github.actor }}"
          #   echo "- **Status**: ‚úÖ Successfully deployed"
          # )
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create deployment summary
        run: |
          cat > deployment-summary.md << EOF
          # Production Deployment Summary
          
          **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Commit**: ${{ github.sha }}
          **Triggered by**: ${{ github.actor }}
          **Metadata Source**: ${{ steps.metadata.outputs.metadata_source }}
          
          ## Deployed Workflow
          - **Name**: ${{ steps.metadata.outputs.workflow_name }}
          - **Version**: ${{ steps.metadata.outputs.version }}
          - **File**: workflows/${{ steps.metadata.outputs.workflow_file }}
          - **Tag**: ${{ steps.metadata.outputs.tag_name }}
          
          ## Deployment Details
          - **Repository**: ${{ github.repository }}
          - **Branch**: prod
          - **Run ID**: ${{ github.run_id }}
          - **Run Number**: ${{ github.run_number }}
          
          ## Deployment Type
          EOF
          
          if [[ "${{ steps.metadata.outputs.metadata_source }}" == "pr_metadata" ]]; then
            echo "- **Type**: Release deployment with full metadata" >> deployment-summary.md
            echo "- **Release Tag**: ${{ steps.metadata.outputs.tag_name }}" >> deployment-summary.md
          elif [[ "${{ steps.metadata.outputs.metadata_source }}" == "pr_title" ]]; then
            echo "- **Type**: Release deployment from PR title" >> deployment-summary.md
            echo "- **Release Tag**: ${{ steps.metadata.outputs.tag_name }}" >> deployment-summary.md
          else
            echo "- **Type**: Direct deployment (no release metadata found)" >> deployment-summary.md
            echo "- **Warning**: Version information unavailable" >> deployment-summary.md
          fi
          
          echo "" >> deployment-summary.md
          echo "## Rollback Instructions" >> deployment-summary.md
          echo "If issues occur, use the following command to rollback:" >> deployment-summary.md
          echo '```bash' >> deployment-summary.md
          echo "npm run backup:restore [backup-name]" >> deployment-summary.md
          echo '```' >> deployment-summary.md
          
          echo "üìÑ Deployment summary created"
          cat deployment-summary.md

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-deployment-${{ github.run_number }}
          path: |
            workflows/backups/
            backups/
            logs/
            deployment-summary.md
          retention-days: 90

      - name: Notify deployment completion
        run: |
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "üìä Summary:"
          echo "  ‚Ä¢ Workflow: ${{ steps.metadata.outputs.workflow_name }}"
          echo "  ‚Ä¢ Version: ${{ steps.metadata.outputs.version }}"
          echo "  ‚Ä¢ File: workflows/${{ steps.metadata.outputs.workflow_file }}"
          echo "  ‚Ä¢ Deployed by: ${{ github.actor }}"
          echo "  ‚Ä¢ Commit: ${{ github.sha }}"
          echo ""
          
          if [[ "${{ steps.metadata.outputs.version }}" == "unknown" ]]; then
            echo "‚ö†Ô∏è Warning: Deployment completed without version information"
            echo "   This deployment was not from a release PR merge"
          fi