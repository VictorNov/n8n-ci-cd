name: Deploy to Production

permissions:
  contents: write
  issues: write
  actions: write

on:
  push:
    branches: [ prod ]

jobs:
  deploy-to-production:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Inject API key into existing config
        run: |
          jq --arg key "${{ secrets.N8N_API_KEY }}" '.n8n.apiKey = $key' config/n8n-config.json > tmp.json && mv tmp.json config/n8n-config.json

      - name: Detect workflows to deploy
        id: detect_workflows
        run: |
          echo "üîç Detecting workflows to deploy from PR title"
          
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Method 1: Try to get the actual PR that was merged
            commit_sha="${{ github.sha }}"
            echo "Looking for PR associated with commit: $commit_sha"
          
            # Use GitHub CLI to find the PR
            pr_info=$(gh pr list --state merged --limit 50 --json number,title,mergeCommit | \
                     jq -r ".[] | select(.mergeCommit.oid == \"$commit_sha\") | .title" 2>/dev/null || echo "")
          
            if [[ -n "$pr_info" ]]; then
              echo "Found PR title: $pr_info"
          
              # Extract workflow name from PR title pattern: "üöÄ Release X.X.X: Workflow Name"
              if [[ "$pr_info" =~ üöÄ\ Release\ [^:]+:\ (.+) ]]; then
                workflow_name="${BASH_REMATCH[1]}"
                echo "workflows=$workflow_name" >> $GITHUB_OUTPUT
                echo "‚úÖ Detected workflow from PR title: $workflow_name"
                exit 0
              fi
            fi
          
            # Method 2: Try commit message
            commit_message=$(git log -1 --pretty=format:"%s")
            echo "Commit message: $commit_message"
          
            # Look for pattern like "üöÄ Release X.X.X: Workflow Name"
            if [[ "$commit_message" =~ üöÄ\ Release\ [^:]+:\ (.+) ]]; then
              workflow_name="${BASH_REMATCH[1]}"
              echo "workflows=$workflow_name" >> $GITHUB_OUTPUT
              echo "‚úÖ Detected workflow from commit: $workflow_name"
              exit 0
            fi
          
            # Method 3: Look for merge commit pattern
            if [[ "$commit_message" =~ Merge\ pull\ request.*üöÄ\ Release\ [^:]+:\ (.+) ]]; then
              workflow_name="${BASH_REMATCH[1]}"
              echo "workflows=$workflow_name" >> $GITHUB_OUTPUT
              echo "‚úÖ Detected workflow from PR merge: $workflow_name"
              exit 0
            fi
          
            echo "‚ùå Could not detect workflow from PR title or commit message"
            echo "Expected patterns:"
            echo "- PR title: 'üöÄ Release X.X.X: Workflow Name'"
            echo "- Commit: 'üöÄ Release X.X.X: Workflow Name'"
            echo "- Merge: 'Merge pull request ... üöÄ Release X.X.X: Workflow Name'"
            echo ""
            echo "üîÑ Falling back to scanning all workflows"
          
            # Method 4: Fallback - scan for workflow files
            workflow_files=$(find workflows -name "*.json" -type f ! -name "_*" 2>/dev/null | head -5)
          
            if [[ -z "$workflow_files" ]]; then
              echo "‚ùå No workflow files found in workflows directory"
              ls -la workflows/ 2>/dev/null || echo "workflows directory does not exist"
              exit 1
            fi
          
            workflows=""
            for file in $workflow_files; do
              filename=$(basename "$file" .json)
              workflow_name=$(echo "$filename" | sed 's/_/ /g' | sed 's/\b\w/\U&/g')
          
              if [[ -n "$workflows" ]]; then
                workflows="$workflows,$workflow_name"
              else
                workflows="$workflow_name"
              fi
              echo "Found: $workflow_name (from $file)"
            done
          
            echo "workflows=$workflows" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Using fallback detection: $workflows"
          
          else
            echo "‚ùå Not a push event, cannot detect workflows"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Run full deployment
        run: |
          echo "üöÄ Running full deployment process"
          
          node scripts/deployment-manager.js full-deploy \
            "${{ steps.detect_workflows.outputs.workflows }}" \
            "${{ github.event.inputs.skip_backup }}" \
            "${{ github.actor }}" \
            "${{ github.sha }}"

      - name: Update releases with deployment status
        if: github.event_name == 'push'
        run: |
          echo "üè∑Ô∏è Updating releases with deployment status"
          
          # This would use gh CLI in actual GitHub Actions
          IFS=',' read -ra WORKFLOWS <<< "${{ steps.detect_workflows.outputs.workflows }}"
          
          for workflow in "${WORKFLOWS[@]}"; do
            workflow=$(echo "$workflow" | xargs)
            echo "Updating release for: $workflow"
          
            # Find latest tag and update (simplified for demo)
            latest_tag=$(git tag -l "${workflow}-*" | sort -V | tail -n1)
            if [[ -n "$latest_tag" ]]; then
              echo "Would update release: $latest_tag"
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Commit deployment artifacts
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if [[ -n "$(git status --porcelain)" ]]; then
            git add workflows/backups/ backups/ logs/ || true
            git commit -m "deploy: ${{ steps.detect_workflows.outputs.workflows }} to production" || true
            git push || true
          fi

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-deployment-${{ github.run_number }}
          path: |
            workflows/backups/
            backups/
            logs/
            deployment-summary.md
          retention-days: 90